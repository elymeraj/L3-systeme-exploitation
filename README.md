# L3-systeme-exploitation
# Résumé détaillé : Introduction aux Systèmes d'Exploitation et Mécanismes des Appels Systèmes

## Introduction aux Systèmes d'Exploitation

### Définition et Rôles d'un Système d'Exploitation (OS)
- Un Système d'Exploitation est un logiciel qui masque la complexité de l'architecture matérielle, rendant l'utilisation de l'ordinateur plus facile et uniforme. Il sert de base aux développeurs en fournissant des interfaces cohérentes et simplifiées pour interagir avec le matériel et les ressources de l'ordinateur.
- **Fonctions principales** :
  - Machine virtuelle : Fournit une abstraction du matériel, permettant aux programmes de s'exécuter sans se soucier des spécificités matérielles.
  - Gestionnaire de ressources : Gère l'accès aux différents périphériques (clavier, écran, imprimante, réseau, etc.) et assure la sécurité et le contrôle d'accès.

### Concepts Clés
- **Processus** : Les programmes en exécution sont encapsulés dans des processus. La gestion des processus inclut la multiprogrammation, la communication entre processus, la gestion des attentes et les droits d'accès.
- **Fichiers** : Les données sont stockées dans des objets appelés fichiers, avec une gestion des droits d'accès.
- **Mémoire** : Gestion de la mémoire d'exécution des programmes, transformée en mémoire virtuelle pour abstraction et sécurité.

### Types de Systèmes d'Exploitation
- **Mono-utilisateur** : Utilisé sur des appareils comme les téléphones.
- **Temps réel** : Utilisé dans des applications critiques comme le nucléaire ou la chimie.
- **Général** : OS multitâches et multi-utilisateurs comme Linux, Windows, Android, et Mac OS.

## Mécanismes des Appels Systèmes

### Appels Systèmes
Les appels systèmes sont des fonctions fournies par le noyau de l'OS, permettant aux programmes en mode utilisateur de demander des services au noyau. Ils sont essentiels pour la gestion des ressources, la communication entre processus, et l'exécution sécurisée de certaines tâches.

### Fonctionnement des Appels Systèmes
1. **Initialisation** : Les codes des appels systèmes sont installés dans une table (Interrupt Handler Table) lors de l'initialisation, chaque fonction système étant associée à un numéro d'interruption.
2. **Passage en Mode Noyau** : Lors de l'appel système, une instruction spéciale (ex: `int` sous Linux) permet de passer en mode noyau avec les arguments nécessaires.
3. **Gestion du Contexte** :
   - Le gestionnaire d'exception (trap handler) sauvegarde le contexte et transfère les données vers l'espace noyau.
   - La vraie fonction système est appelée, traitant la requête.
   - Le résultat est transmis en retour à l'espace utilisateur, avec restauration du contexte initial.

### Types d'Appels Systèmes
- **Appel Bloquant** : Le processus appelant attend la fin de l'appel système pour continuer. Exemples : `open`, `read`, `write`.
- **Appel Non Bloquant** : Un délai est fixé, et la main est redonnée au processus appelant si l'appel système n'a pas terminé dans ce délai. Exemples : `read`, `write` en mode non bloquant.
- **Attente Active** : Le processus appelle de manière répétitive une fonction non bloquante jusqu'à ce qu'elle réussisse. Exemple : `while (1) { r = read(...); if (r >= 0) break; }`

### Exemples d'Appels Systèmes
- **`read`** : Lit des données à partir d'un fichier ou d'un périphérique.
- **`open`** : Ouvre un fichier.
- **`fork`** : Crée un nouveau processus en copiant le processus courant.
- **`dup`** : Duplique un descripteur de fichier, permettant à deux descripteurs de référencer le même fichier ouvert.

### Sémaphores et Synchronisation
- Les sémaphores sont des mécanismes utilisés pour gérer l'accès concurrent aux ressources partagées, assurant une exclusion mutuelle et évitant les interblocages.

## Gestion de la Mémoire

### Concepts Fondamentaux de la Mémoire
- **Mémoire Virtuelle**: La mémoire virtuelle permet de donner aux processus l'illusion qu'ils disposent de la totalité de la mémoire physique. Elle utilise une table de pages pour mapper les adresses virtuelles aux adresses physiques. La mémoire virtuelle facilite la gestion et l'isolation des processus.
- **Segmentation**: La mémoire est divisée en segments logiques tels que le code, les données, et la pile. Chaque segment peut croître ou décroître indépendamment.
- **Pagination**: La mémoire virtuelle est divisée en blocs de taille fixe appelés pages. La pagination évite la fragmentation externe et permet une gestion plus flexible de la mémoire.

### Mémoire Virtuelle par Pagination

### Pagination
- **Pages et Cadres de Pages**: Un processus est divisé en pages de taille fixe qui sont mappées à des cadres de pages en mémoire physique.
- **Table des Pages**: Chaque processus possède une table des pages qui contient des entrées mappant les pages virtuelles aux cadres physiques.
- **TLB (Translation Lookaside Buffer)**: Un cache matériel utilisé pour accélérer la traduction des adresses virtuelles en adresses physiques.

### Fonctionnement
1. **Adresse Logique**: L'adresse générée par le CPU est une adresse logique divisée en un numéro de page et un décalage au sein de la page.
2. **Traduction**: La MMU (Memory Management Unit) utilise la table des pages pour convertir l'adresse logique en adresse physique.
3. **TLB**: Si l'entrée correspondante est trouvée dans le TLB, la traduction est rapide. Sinon, la table des pages est consultée, et le TLB est mis à jour.

### Politiques de Changement de Pages

### Problème de Changement de Pages
Lorsqu'une page référencée n'est pas présente en mémoire (page fault), l'OS doit choisir une page à remplacer. Plusieurs politiques de remplacement de pages existent pour minimiser le taux de défaut de page et optimiser les performances.

### Politiques de Remplacement de Pages
1. **FIFO (First-In-First-Out)**
   - **Principe**: La première page chargée en mémoire est la première à être remplacée.
   - **Avantage**: Simple à implémenter.
   - **Inconvénient**: Peut entraîner l'anomalie de Belady où plus de cadres de pages peuvent conduire à un taux de défaut de pages plus élevé.

2. **LRU (Least Recently Used)**
   - **Principe**: La page la moins récemment utilisée est remplacée.
   - **Avantage**: Efficace car il repose sur l'hypothèse que les pages récemment utilisées seront probablement utilisées à nouveau.
   - **Inconvénient**: Difficile à implémenter exactement car il nécessite de suivre l'historique d'utilisation de toutes les pages.

3. **Optimal**
   - **Principe**: Remplace la page qui ne sera pas utilisée pendant le plus long délai dans le futur.
   - **Avantage**: Offre le taux de défaut de pages le plus bas possible.
   - **Inconvénient**: Impossible à implémenter en pratique car il nécessite une connaissance future parfaite.

4. **NRU (Not Recently Used)**
   - **Principe**: Utilise deux bits (référence et modification) pour classifier les pages et choisit une page non référencée récemment.
   - **Avantage**: Simplifie la mise en œuvre tout en étant plus performant que FIFO.
   - **Inconvénient**: Moins précis que LRU et optimal.

5. **Clock**
   - **Principe**: Variante de NRU où les pages sont organisées en cercle avec un pointeur. Le pointeur avance circulairement et remplace la première page avec le bit de référence à zéro.
   - **Avantage**: Efficace en termes de temps de recherche et d'implémentation.
   - **Inconvénient**: Peut parfois se comporter comme FIFO.

## Gestion des Processus

### Définition d'un Processus
Un processus est un programme en cours d'exécution, comprenant :
1. **Code** : Ensemble d'instructions à exécuter.
2. **Données** : Incluant les données statiques et dynamiques nécessaires.
3. **Environnement** : Structure allouée par le système d'exploitation pour contrôler et gérer le processus.

Chaque processus possède une arborescence où chaque processus a un parent unique, à l'exception du premier processus, `init`.

### États d'un Processus
Les processus passent par différents états au cours de leur cycle de vie :
1. **Prêt** : Le processus est prêt à être exécuté mais attend son tour.
2. **Actif** : Le processus utilise actuellement le processeur.
3. **Bloqué/Endormi** : Le processus attend une ressource.
4. **Suspendu** : Le processus est temporairement arrêté par l'utilisateur.
5. **Zombie** : Le processus a terminé son exécution mais attend la collecte de ses ressources.

Un processus peut être mis en état suspendu volontairement avec la fonction système `sleep(unsigned int)`.

### Création d'un Processus
1. **Fork** : Le processus parent crée un nouveau processus fils via l'appel système `fork()`. Le fils hérite de l'environnement d'exécution du père mais obtient un nouvel identifiant unique (`pid`). Les fichiers ouverts sont dupliqués mais partagent les mêmes décalages.
2. **Exec** : Le processus fils peut remplacer son code par un autre programme en utilisant la famille de fonctions `exec*(chemin, arg, ...)`.
3. **Processus Orphelins** : Si un processus parent termine avant son fils, le processus `init` adopte le fils pour éviter les processus zombies.

### Blocs de Contrôle d'un Processus
Chaque processus est associé à un bloc de contrôle contenant :
- **Pid** : Identifiant du processus.
- **État** : État actuel du processus.
- **Compteur ordinal** : Position actuelle dans l'exécution.
- **Mémoire allouée** : Information sur la mémoire utilisée par le processus.
- **Descripteurs de fichiers ouverts** : Fichiers actuellement ouverts par le processus.

### Ordonnancement des Processus
Les processus sont planifiés par le système d'exploitation à l'aide de différentes stratégies d'ordonnancement pour assurer une utilisation équitable et efficace du processeur :
1. **FIFO (First-In-First-Out)** : Les processus sont exécutés dans l'ordre de leur arrivée.
2. **Tourniquet** : Chaque processus reçoit un quantum de temps fixe pour s'exécuter avant de céder le processeur.
3. **Le plus court d'abord** : Les processus les plus courts sont exécutés en priorité.
4. **Système interactif** : Combine les priorités et l'interaction pour améliorer la réactivité.

### Threads
Un thread est un chemin d'exécution léger au sein d'un processus. Les threads partagent les ressources du processus, ce qui permet une communication rapide et efficace entre eux. Cependant, ils nécessitent des mécanismes de synchronisation pour éviter les conflits.

## Pilotes (Drivers)

### Fonction des Pilotes
- Les pilotes sont des programmes qui permettent au système d'exploitation de communiquer avec le matériel. Ils agissent comme des traducteurs entre l'OS et les périphériques.

### Types de Pilotes
- **Pilotes de périphériques** : Gèrent les interactions avec les matériels comme les imprimantes, disques, claviers.
- **Pilotes de systèmes** : Gèrent des fonctions comme la gestion de la mémoire et les opérations réseau.

### Gestion des Pilotes
- **Chargement Dynamique** : Les pilotes peuvent être chargés et déchargés dynamiquement en fonction des besoins.
- **Interface Uniforme** : Fournir une interface uniforme pour faciliter la communication entre le noyau et les différents types de matériel.

## Architecture Modulaire

### Principes de l'Architecture Modulaire
- **Modularité** : Séparation des différentes fonctions du système d'exploitation en modules indépendants.
- **Avantages** :
  - **Maintenance** : Facilite la mise à jour et la maintenance des composants individuels.
  - **Personnalisation** : Permet de personnaliser l'OS en ajoutant ou retirant des modules sans affecter le reste du système.
- **Exemples** :
  - **Micro-noyaux** : Structure où le noyau est minimal et les services du système d'exploitation sont exécutés dans des espaces d'adressage utilisateur distincts.
  - **Modules du noyau Linux** : Les fonctionnalités peuvent être ajoutées ou retirées sans redémarrer le système, augmentant ainsi la flexibilité et l'efficacité.
